#include "String.hpp"

/* =========================================================================== */
/* ============================ Приватные методы ============================= */
/* =========================================================================== */

// Ввод (приватный метод)
void String::enterStr(std::istream& in)
{
    std::cout << "Please enter string!\n";
    in.getline(str, this->size + 1);
}

// Вывод (приватный метод)
void String::printStr(std::ostream& out)
{
    out << str;
}


/* =========================================================================== */




/* =========================================================================== */
/* ============================== Конструкторы =============================== */
/* =========================================================================== */

// Конструктор по умолчанию
String::String() :String(10) { str[9] = '\0'; }

// Конструктор с параметром
String::String(size_t size)
{
    this->size = size;
    try {
        str = new char[size + 1];
    }
    catch (std::bad_alloc& ex) {
        std::cout << ex.what(); 
    }
    
    for (size_t i = 0; i <= size; i++)
    {
        str[i] = '\0';
    }
}

// Конструктор копирования
String::String(const String& obj): size(obj.size), str (new char[size + 1])
{
    for (int i = 0; i < size; i++)
    {
        this->str[i] = obj.str[i];
    }
    this->str[size] = '\0';
}

// Конструктор с параметром
String::String(std::string s)
{
    this->size = s.length();
    str = new char[size + 1];
    for (size_t i = 0; i < size; i++)
    {
        str[i] = s[i];
    }
    str[size] = '\0';
}

// Деструктор
String::~String()
{
    delete[] str;
    str = nullptr;
}


/* =========================================================================== */




/* =========================================================================== */
/* ============================ Геттеры ====================================== */
/* =========================================================================== */

// Получение массива
char* String::fillString() const
{
    return this->str;
}

// Получение размера
size_t String::getSise() const
{
    return size;
}

/* =========================================================================== */




/* =========================================================================== */
/* ================================= Сеттеры ================================= */
/* =========================================================================== */

// Установка размера
void String::setSize(size_t size)
{
    if (size <= 0) {
        throw std::invalid_argument("wrong size\n");
    }
    String temp(this->str);
    this->size = size + 1;
    delete[] str;
    str = new char[size + 1];
    for (size_t i = 0; i < size; i++)
    {
        str[i] = temp.str[i];
    }
    str[size] = '\0';
}
/* ========================================================================= */




/* =========================================================================== */
/* ============== Перегрузки бинарных арифметических операторов ============== */
/* =========================================================================== */

// Бинарное сложение   [ строка + строка]
String String::operator+(const String& obj)
{
    String newarray(this->str);
    newarray.setSize(this->size + obj.size);
    size_t j = 0;
    for (size_t i = (this->size); i < newarray.size - 1; i++)
    {
       
        newarray.str[i] = obj.str[j++];
    }
    newarray.str[newarray.size - 1] = '\0';
    return newarray;
}

// Бинарное сложение   [ строка + массив символов]
String String::operator+(const char* str)
{

    String newarray(this->str);
    newarray.setSize(this->size + strlen(str));
    size_t j = 0;
    for (size_t i = this->size; i < newarray.size - 1; i++)
    {

        newarray.str[i] = str[j++];
    }
    newarray.str[newarray.size - 1] = '\0';
    return newarray;
}
/* ======================================================================== */

/* =========================================================================== */
/* =================== Перегрузка дефолтного оператора присваивания ==================== */
/* =========================================================================== */
String& String::operator=(String obj)
{
    if (this != & obj)
    {
        this->size = obj.size;
        delete[] this->str;
        this->str = new char[size];
        for (size_t i = 0; i < size; i++)
        {
            this->str[i] = obj.str[i];
        }
    }
    
    return *this;
}

/* ======================================================================== */



/* =========================================================================== */
/* =================== Перегрузки операторов присваивания ==================== */
/* =========================================================================== */

// Оператор присваивания сложения
String& String::operator+=(String obj)
{
 
    this->setSize(this->size + obj.size);
    size_t j = 0;
    for (size_t i = (this->size - obj.size-1); i < this->size - 1; i++)
    {

        this->str[i] = obj.str[j++];
    }
    this->str[this->size - 1] = '\0';
    return *this;
}
// Оператор присваивания сложения с массивом строк
String& String::operator+=(const char* str)
{
    this->setSize(this->size + strlen(str));
    size_t j = 0;
    for (size_t i = (this->size - strlen(str) - 1); i < this->size - 1; i++)
    {

        this->str[i] = str[j++];
    }
    this->str[this->size - 1] = '\0';
    return *this;
}
/* ======================================================================== */




bool String::operator==(String obj) {
    if (obj.size != this->size) return false;
    for (int i = 0; i < obj.size; i++)
    {
        if (obj.str[i] != this->str[i]) return false;
    }
    return true;
}
bool String::operator!=(String obj) 
{
    if (String::operator==(obj))
    {
        return false;
    }
    return true;
}


/* =========================================================================== */




/* =========================================================================== */
/* ============================ Методы  ====================================== */
/* =========================================================================== */
// Метод копирования
String String::copy(size_t start, size_t size)
{
    String temp(size);
    size_t j = 0;
    for (size_t i = start; i < start + size; i++)
    {
        temp.str[j] = this->str[i];
        j++;
    }
    temp.str[temp.size - 1] = '\0';
    return temp;
}
/* =========================================================================== */




/* =========================================================================== */
/* ===================== Перегрузки операторов ввода ======================== */
/* =========================================================================== */

// Оператор ввода (дружественный)
std::istream& operator >> (std::istream& in, String& str) 
{
    str.enterStr(in);
    return in;
}
/*========================================================================== = */




/* =========================================================================== */
/* ===================== Перегрузки операторов вывода ======================== */
/* =========================================================================== */

// Оператор вывода (дружественный)
std::ostream& operator<< (std::ostream& out, String& str) {
    str.printStr(out);
    out << '\n';
    return out;
}
/*========================================================================== = */